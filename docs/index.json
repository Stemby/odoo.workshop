[
{
	"uri": "https://metadonors.github.io/odoo.workshop/models/campi_base/",
	"title": "Campi Base",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://metadonors.github.io/odoo.workshop/inheritance/teoria/",
	"title": "Preambolo",
	"tags": [],
	"description": "",
	"content": "Per apportare modifiche o aggiungere funzionalità ai moduli e alle applicazioni esistenti, Odoo ci mette a disposizione diversi strumenti in base a cosa e dove vogliamo intervenire.\nOdoo ha dai meccanismi interni specifici che si basano sul concetto di Ereditarietà. Tramite questi meccanismi e\u0026rsquo; possibile modificare Modelli esistenti, Viste oppure Dati (come le regole di accesso).\nIn questo capito andremo ad aggiungere una funzionalità all\u0026rsquo;applicazione Todo creata in precedenza. Attualmente ogni utente può lavorare solo sui suoi task, perchè non aggiungere qualche funzionalità di social networking come la possibilità di condividere i task e di commentarli con diversi utenti?\nPer affrontare i meccanismi di eredità implementeremo queste funzionalità in un nuovo modulo che estende quello precedentemente creato.\nQuesto è il nostro piano:\n Estendere il modello TodoTask aggiungendo l\u0026rsquo;utente attualmente in carico Modificare la logica applicativa per far si che ogni utente lavori solo sui task di cui è incaricato Estendere le viste per aggiungere i campi nessari a quanto sopra Aggingere un wall di messaggi in fondo a ogni Task dove gli utenti possono commentare e seguire (tipo Twitter follow) l\u0026rsquo;evoluzione del task  Per procedere dobbiamo creare un nuovo modulo nella stessa cartella contenente il modulo todo_app. Lo chiameremo todo_user e creeremo al suo interno il file __manifest__.py\n todo_user/ __init__.py __manifest__.py  Nel file di manifesto inseriemo questo contenuto\n{ 'name': 'Multiuser TODO', 'description': 'Estende la Todo app per farla diventare Multi Utente', 'author': 'Fabrizio Arzeni', 'depends': ['todo_app'], }  Notate che abbiamo messo una dipendenza esplicita sul modulo todo_app, questo permettera a Odoo di inizializzare questo modulo dopo aver inizializzato todo_app.\nUn\u0026rsquo;altra differenza è che non abbiamo esplicitato application=True in quanto con questo modulo non andremo a creare una nuova applicazione ma apporteremo solo modifiche a un\u0026rsquo;altra già esistente.\nUna volta fatto questo possiamo aggiornare la lista dei moduli e installare il modulo todo_user nel nostro Odoo.\nA questo punto possiamo andare a vedere come si estende il modello TodoTask\n"
},
{
	"uri": "https://metadonors.github.io/odoo.workshop/first_app/primo_modulo/",
	"title": "Scaffolding",
	"tags": [],
	"description": "",
	"content": " In questa sezione andremo a creare il nostro primo modulo. L\u0026rsquo;applicazione d\u0026rsquo;esempio che creeremo durante il corso è una classica Todo App. Per realizzarla attraverseremo le classiche fasi di sviluppo di un applicazione Odoo.\nLo scheletro del modulo Odoo offre un suo meccanismo di scaffolding piuttosto primitivo per creare nuovi moduli, è possibile visualizzare il suo funzionamento lanciando questo comando dalla cartella contente l\u0026rsquo;ambiente odoo.dockerenv:\n$ docker-compose run odoo odoo scaffold --help  Nella pratica la comunità si è però concentrata su un altro strumento di scaffolding, mrbob con i template specifici per gli addon Odoo.\nVi può essere utile quando affronterete il vostro primo modulo in autonomia, ma durante questo corso creeremo tutta la struttura manualmente in modo da capirne meglio i vari aspetti.\nQuindi cominciamo Un modulo Odoo è una cartella contenente un file __manifest__.py. La cartella deve essere anche un modulo python valido, deve quindi contenere un file __init__.py.\nIl nome della cartella del modulo è un nome tecnico non visibile all\u0026rsquo;utente, deve essere valido in python quindi niente deve cominciare con una lettera e sono validi solo lettere, numeri e underscore. Nel nostro caso useremo quindi il nome todo_app.\nAll\u0026rsquo;interno della cartella addons dell\u0026rsquo;ambiente docker che abbiamo scaricato, creiamo la cartella todo_app con la seguente struttura:\ntodo_app/ __init__.py __manifest__.py  A questo punto è ora di aprire il nostro editor di testo per modificare il file __manifest__.py, dove inseriremo il seguente contenuto:\n{ 'name': 'Applicazione TODO', 'description': 'Gestisci i tuoi TODO', 'author': 'Fabrizio Arzeni', 'depends': ['base'], 'application': True }  Il campo depends indica i moduli da cui dipende la nostra applicazione, se non sono presenti quando verra installata, Odoo li installerà automaticamente. È necessario inserirla soprattutto quando si fa riferimento a funzionalità di terze parti.\nIn questo caso abbiamo usato solo alcuni dei valori definibili nel manifesto di un modulo, nei casi reali questo file è sarà più complesso. Per una spiegazione più dettagliata del suo contenuto potete consultare la pagina della documentazione di Odoo sul file manifest.\nI path degli addon Nel nostro caso Odoo sarà in grado di trovare questa applicazione perchè l\u0026rsquo;abbiamo creata nella cartella addons dell\u0026rsquo;ambiente. Ma quella cartella è stata configurata per essere fra quelle papabili dove Odoo cerca gli addon all\u0026rsquo;avvio. È possibile specificare diversi percorsi dove odoo cerca gli addons disponibili ad essere installati, fate riferimento alla variabile addons-path disponibile sia nel file di confiurazione di odoo che da linea di comando.\nInstallazione del modulo A questo punto è possibile installare il modulo. Come abbiamo fatto nella sezione precedente possiamo andare nella lista delle App, scrive todo nella barra di ricerca e cliccare sul pulsante installa sul nostro modulo.\nMa\u0026hellip;il nostro modulo non c\u0026rsquo;è.\nLa modalità sviluppatore Il nostro modulo non c\u0026rsquo;è perchè Odoo nella sua fase iniziale mette in cache tutti i moduli che sono presenti in quel momento. Per far apparire il nostro modulo dobbiamo dirgli di ricaricare la lista delle applicazioni.\nPer farlo dobbiamo entrare nella modalità sviluppatore che sarà essenziale per tutto il nostro lavoro.\nPer attivarla bisogna andare nell\u0026rsquo;applicazione \u0026lsquo;Settings\u0026rsquo; e premere sulla scritta \u0026lsquo;Activate the developer mode\u0026rsquo; presente sulla destra sotto la versione di Odoo.\nUna volta fatto possiamo tornare nella lista delle App e a questo punto sarà presente il bottone \u0026lsquo;Update App List\u0026rsquo;. Premetelo e rieffettuate la ricerca del modulo todo che dovrebbe essere ora disponibile per essere installato\nCliccate su installa ed il primo passo è compiuto\nNota bene Sviluppare moduli è un processo iterativo e spesso dopo dei cambiamenti, in particolare sul database, sarà necessario riavviare odoo dicendogli esplicitamente di aggiornare i moduli interessati. Se la modifica invece è solo al codice python o a delle viste sarà sufficiente riaggiornare la pagina perchè il sistema è stato lanciato in modalita di sviluppo (con l\u0026rsquo;opzione \u0026ndash;dev=all vedi docker-compose.yml). In fase di produzione qualsiasi aggiornamento comporta il riavvio del sistema\nContinua Ora che abbiamo creato e installato la nostra prima applicazione possiamo continuare andando a modellare i nostri dati definendo Modelli e Campi.\n"
},
{
	"uri": "https://metadonors.github.io/odoo.workshop/basics/precorso/",
	"title": "Precorso",
	"tags": [],
	"description": "",
	"content": " Prima di arrivare al corso sarebbe opportuno avere già installati e funzionanti un edito di testo, Git, Docker e Docker Compose\nEditor di testo Non ci sono preferenze per l\u0026rsquo;editor di testo, ovviamente è opportuno usarne uno che aiuti a lavorare con codice python e javascript\nUn elenco di alcuni possibili editor:\n VSCode https://code.visualstudio.com/ Atom https://atom.io/ Sublime Text https://www.sublimetext.com/  Git L\u0026rsquo;installazione di Git varia in base al sistema operativo utilizzato, ecco come procedere:\nLinux Su Ubuntu/Debian è sufficiente dare da terminale:\n$ sudo apt install git  Su Redhat/Centos\n$ sudo yum install git  Mac Su mac, se non l\u0026rsquo;avete gia\u0026rsquo; fatto, prima dell\u0026rsquo;installazione di Git bisogna procedere a installare Homebrew (cosa piuttosto importante se si intende sviluppare software)\nAprite un terminale e copia-incollate il seguente comando:\nruby -e \u0026quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\u0026quot; brew doctor  Vi chiedera di installare la Command Line Developer Tool di Apple. Cliccate Install per confermare. Una volta terminato premete Invio per terminare l\u0026rsquo;installazione di Homebrew.\nEffettuato queso passaggio potete installare Git da terminale con il comando:\nbrew install git  Windows Su Windows scaricate l\u0026rsquo;applicazione Git for Windows e installatela\nDocker e Docker Compose Docker è uno strumento di pacchetizzazione generico per le nostre applicazioni. Semplifica l\u0026rsquo;installazione di ambienti complessi sia in fase di sviluppo che di produzione. Per noi è utile per riuscire ad avere una piattaforma uguale per tutti su cui lavorare. Il risultato di una pacchettizzazione con Docker è chiamato Container. Un container è a tutti gli effetti un eseguibile che potete lanciare da linea di comando passandogli parametri secondo necessità.\nNon è necessario utilizzare la versione Enterprise (EE), utilizzeremo la Community Edition (CE) che ha tutte le funzionalità necessarie (ma senza la stessa assistenza)\nDocker Compose invece serve a definire e lanciare diversi container in maniera orchestrata. Con compose si utilizza un file di configurazione YAML per definire tutti i servizi di cui è composta la nostra applicazione, per esempio: odoo, il database e il server web. Una volta terminata la configurazione è possibile creare e lanciare tutti i servizi di cui abbiamo bisogno con un singolo comando.\nAnche per questi strumenti l\u0026rsquo;installazione varia in base al sistema operativo usato.\nLinux Docker Per Ubuntu:\nPer prima cosa aggiungete il repository docker ufficiale:\n$ sudo add-apt-repository \\ \u0026quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs) \\ stable\u0026quot;  Aggiornate l\u0026rsquo;indice dei pacchetti:\n$ sudo apt-get update  Infine installate l\u0026rsquo;ultima versione di docker:\n$ sudo apt-get install docker-ce  Per le altre distribuzioni e\u0026rsquo; possibile trovare le istruzioni dettagliate nella pagina ufficiale della documentazione di Docker\nDocker Compose Per installare Compose:\nScaricate l\u0026rsquo;eseguibile con il comando:\nsudo curl -L https://github.com/docker/compose/releases/download/1.21.2/docker-compose-$(uname -s)-$(uname -m) -o /usr/local/bin/docker-compose  Aggiungete il permesso d\u0026rsquo;esecuizione al file binario:\nsudo chmod +x /usr/local/bin/docker-compose  Testate l\u0026rsquo;installazione con:\n$ docker-compose --version docker-compose version 1.21.2, build 1719ceb  Mac Docker e Docker Compose Per Mac è sufficiente scaricare l\u0026rsquo;applicazione ufficiale dall\u0026rsquo;Docker Store\nPer maggiori informazioni qui trovate la pagina di documentazione specifica\nWindows Docker e Docker Compose Come per Mac è sufficiente scaricare l\u0026rsquo;applicazione ufficiale dall\u0026rsquo;Docker Store\nPer maggiori informazioni qui trovate la pagina di documentazione specifica\nContinua\u0026hellip; Una volta terminata questa procedura siete pronti ad iniziare il corso installando l\u0026rsquo;ambiete di sviluppo Odoo\n"
},
{
	"uri": "https://metadonors.github.io/odoo.workshop/basics/",
	"title": "Iniziare",
	"tags": [],
	"description": "",
	"content": " Capitolo 1 Iniziare Per imparare è necessario poterci mettere le mani sopra, quindi installiamo il necessario\n"
},
{
	"uri": "https://metadonors.github.io/odoo.workshop/models/relazioni/",
	"title": "Relazioni",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://metadonors.github.io/odoo.workshop/inheritance/estendere_modelli/",
	"title": "Estendere i Modelli",
	"tags": [],
	"description": "",
	"content": " In Odoo i nuovi modelli, o le estensioni di quelli esistenti, si creano definendo delle classi Python specifiche. Il meccanismo di ereditarietà di Odoo non si base su quello delle classi Python, ma su un suo approccio interno che si basa sull\u0026rsquo;attributo _inherit specificato nella class.\nIn base a come viene utilizzato si possono ottenere differeneti meccanismi di ereditarietà.\nNoi cominceremo con il più semplice dove la classe figlia eredita tutte le funzionalità del padre e dove noi possiamo semplicemente apportare le modifiche che ci interessano.\nPer prima cosa andiamo a creare la cartella models/ con il file __init__.py e il file todo_task.py che ospiterà le nostre modifiche, ottenendo questa struttura:\n todo_user/ models/ __init__.py todo_task.py __init__.py __manifest__.py  Inseriamo gli import necessari per far funzionare il codice Python mettendo all\u0026rsquo;interno del file todo_user/__init__.py\nfrom . import models  e all\u0026rsquo;interno del file todo_user/models/__init__.py\nfrom . import todo_task  Aggiungere campi a un modello A questo punto siamo pronti a modificare il file todo_task.py per estendere il nostro precedente modello. Aprimo il file e scriviamo quanto segue\n# -*- coding: utf-8 -*- from odoo import models, fields, api class TodoTask(models.Model): _inherit = 'todo.task' user_id = fields.Many2one('res.users', 'Assigned to') deadline_date = fields.Date('Deadline')  Come vedete non c\u0026rsquo;è nessun meccanismo python di eredità e anche il nome della classe è irrilevante a questi fini. Il punto chiave è l\u0026rsquo;attributo _inherit che dice ad Odoo di estendere il modello todo.task. Le altre linee sono normali dichiarazioni di campi.\nModificare campi esistenti Aggiungere campi è piuttosto semplice, ma è anche possibile apportare modifiche a campi esitenti. Per farlo è sufficiente ridichiara il campo e passare solo gli attributi che si vogliono andare a modificare.\nPer esempio per modificare il tooltip del campo name possiamo aggiungere il campo\nname = fields.Char(help=\u0026quot;Cosa bisogna fare?\u0026quot;)  Per vedere se le modifiche che abbiamo apportato sono corrette dobbiamo effettuare l\u0026rsquo;upgrade del modulo todo_user, ricaricare la pagina e controllare che il tooltip presente nella Form View dei Todo Task sia aggiornata con quando abbiamo scritto, come nell\u0026rsquo;immagine che segue\nModificare i metodi del modello Con l\u0026rsquo;eredità dei modelli, oltre ai campi, è posssibile anche i metodi associati. Aggiungere un nuovo metodo è semplice: è sufficiente dichiarare una nuova funzione. Se invece si vuole modificare il comportamento di un metodo esistente, si può procedere sovrascrivendo il metodo stesso ed è possibile, se necessario, invocare comunque il metodo padre con la funzione super() di Python.\nCambiare gli argomenti dei metodi esistenti può essere pericoloso perchè non potete sapere chi li sta già invocando. In caso sia necessario è opportuno inizializare gli argomenti con un valore predefinito.\n Nel nostro caso vogliamo che quando un utente invoca il metodo do_clear_done non vengano chiusi tutti i task completati ma solo quelli assegnati all\u0026rsquo;utente stesso oppure quelli non assegnati.\nPer farlo aggiungiamo il seguente metodo all\u0026rsquo;oggetto TodoTask nel file models/todo_task.py\n@api.multi def do_clear_done(self): dones = self.search([ ('is_done', '=', True), '|', ('user_id', '=', self.env.uid), ('user_id', '=', False) ]) dones.write({'active': False})  Vediamo invece come estendere un metodo, senza sovrascrivere completamente la logica presente nel modello originale. Per la funzione do_toggle_done vogliamo aggiungere un controllo in caso l\u0026rsquo;utente stia cercando di chiudere un task che non gli è assegnato. In quel caso lanciamo un errore, altrimenti procediamo come consueto.\nPer ottenere questo comportamente modifichiamo il file models/todo_task.py, aggiungendo neglle importazioni iniziali\nfrom odoo.exceptions import ValidationError  e nel corpo della classe il metodo\n@api.multi def do_toggle_done(self): for task in self: if tast.user_id != self.env.user: raise ValidationError(\u0026quot;Solo l'incaricato può chiudere questo task\u0026quot;) return super(TodoTask, self).do_toggle_done()  Continua A questo punto per poter testare queste modifiche è necessario apportare delle modifiche alle viste di questo modello estendendo le Viste\n"
},
{
	"uri": "https://metadonors.github.io/odoo.workshop/first_app/primo_modello/",
	"title": "I modelli",
	"tags": [],
	"description": "",
	"content": " Ora che abbiamo la nostra prima applicazione iniziamo ad aggiungere un semplice modello.\nI modelli sono la M del paradigma MVC, rappresento i dati su cui la nostra applicazione lavora. Sono dei modelli i Prodotti, le Fatture, i Clienti, etc.\nI modelli sono descritti da classi Python che ereditano da una classe generica del framework Odoo le loro funzionalità base. Il loro compito principale è quello di tradurre il loro schema sulle tabelle del database. Odoo si occuperè poi automaticamente di installare e aggiornare il database in fase di upgrade del modulo.\nIl nostro primo modello Il modello che andremo a definire è un semplice Todo Task, ogni task avrà un campo testo per la descrizione e un campo booleano per segnare il task come completato.\nCreazione del modello Tutti i modelli di un modulo risiedono all\u0026rsquo;interno di una cartella models all\u0026rsquo;interno del modulo, e al suo interno aggiungiamo il file todo_model.py e il file __init__.py, necessario per far capire a Python che il contenuto di models è importabile.\nAvremo cosi questa struttura:\n todo_app/ models/ __init__.py todo_model.py __init__.py __manifest__.py  All\u0026rsquo;interno del file del modello todo_model.py aggiungiamo questo contenuto:\n# -*- coding: utf-8 -*- from odoo import models, fields class TodoTask(models.Model): _name = 'todo.task' _description = 'Todo Task' name = fields.Char('Description', required=True) is_done = fields.Boolean('Done?') active = fields.Boolean('Active?', default=True)  A questo punto Odoo non sa ancora dell\u0026rsquo;esistenza della nostra cartella dei modelli, ne che e\u0026rsquo; stato definito un file todo_models.py. Per rendere la nostra modifica effettiva dobbiamo aggiustare le importazioni dei file negli __init__.py\nAll\u0026rsquo;interno del file _todo_app/__init__.py aggiungiamo:\nfrom . import models  All\u0026rsquo;interno del file _todo_app/models/__init__.py aggiungiamo:\nfrom . import todo_model  A questo punto Odoo sarà in grado di riconoscere e manipolare il modello appena creato.\nUpgrade del modulo Ogni volta che effettuiamo una modifica ad un modello, dobbiamo dire manualmente ad odoo di aggiornare (migrare) il database, per farlo abbiamo un comando apposito da passare ad odoo.\nApri una nuova shell e dalla cartella contentente il fiel docker_compose.yml, scrivi:\n$ docker-compose run odoo upgrade todo_app  Che fra le tante cose che scrive, dovrebbe anche dire:\n2018-06-28 09:46:34,017 1 INFO demo odoo.modules.registry: module todo_app: creating or updating database tables  Controllare il modello Attualmente non abbiamo ancora definito nè viste nè modelli, quindi non ci è possibile vedere semplicemente se le modifiche sono state apportate al sistema. Abbiamo un ottima occasione però per vedere un altro strumento di sviluppo che Odoo ci offre. Attiviamo la modalità sviluppatore e andiamo nel modulo:\nSettings -\u0026gt; Technical -\u0026gt; Database Structure -\u0026gt; Models\nCerchiamo il modello todo.task e sulla lista clicchiamo sul risultato ottenuto. Se tutto è andato dovremmo vedere una schermata tipo questa:\nChe ci conferma che il modello e i campi che abbiamo definito sono stati effettivamente creati. Come vede Odoo si occupa automaticamente di aggiungere altri campi, tra cui i più rilevanti sono:\n id è l\u0026rsquo;identificatore unico numerico assegato a ogni istanza del nostro modello create_date e create_uid specificano quando e chi ha creato l\u0026rsquo;istanza write_date e write_uid specificano quando e chi ha modificato l\u0026rsquo;istanza  Questi campi vengono aggiunti automaticamente a tutti i modelli che verranno creati.\nContinua Adesso che abbiamo un modello di dati su cui lavorare possiamo creare le prime viste che ci permettarann di interagire con il database tramite l\u0026rsquo;interfaccia web.\n"
},
{
	"uri": "https://metadonors.github.io/odoo.workshop/first_app/",
	"title": "La prima applicazione",
	"tags": [],
	"description": "",
	"content": " Chapter 2 La prima applicazione Odoo è un framework MVC, i Modelli sono la M del paradigma e ci permettono di rappresentare i nostri dati in maniera strutturata, come per esempio i Prodotti, le Vendite, le Fatture o i Clienti. La C sta per controller che rappresenta la parte funzionale dei nostri dati. La V invece sono le viste, i componenti che descrivono l\u0026rsquo;interfaccia utente.\n"
},
{
	"uri": "https://metadonors.github.io/odoo.workshop/basics/installazione/",
	"title": "Installazione",
	"tags": [],
	"description": "",
	"content": " Una volta installati gli strumenti di sviluppo come descritto nella sezione Precorso possiamo procedere ad installare l\u0026rsquo;ambiente di odoo che utilizzeremo in questo corso.\nInstallazione dell\u0026rsquo;ambiente di sviluppo Scaricate l\u0026rsquo;ambiente docker che utilizzeremo dal github in una cartella sul nostro computer. Aprite un terminale e digitate:\n$ git clone https://github.com/metadonors/odoo.docker.git  Entriamo nella cartella appena scaricata:\n$ cd odoo.docker  Infine diciamo a compose di tirare su l\u0026rsquo;ambiente:\n$ docker-compose up  Compose comincerà a scaricare tutte le nostre dipendenze, odoo, nginx e il database. La procedura può metterci diversi minuti in base alla connessione a internet disponibile.\nIn seguito verranno avviati i vari componenti: odoo, postgres - il database - e nginx - il server web. Al primo avvio odoo dovrà inizializzare la struttura del database (anche questa operazione potrebbe impiegare qualche minuto).\nUna volta terminata, aprite il vostro browser all\u0026rsquo;indirizzo:\nhttp://localhost\ndovreste vedere la schermata di accesso di Odoo. Per entrare inserite le credenziali predefinite:\nUsername: admin Password: admin\nContinua\u0026hellip; Una volta terminata l\u0026rsquo;installazione possiamo affrontare i concetti base\n"
},
{
	"uri": "https://metadonors.github.io/odoo.workshop/models/computed_fields/",
	"title": "Computed Fields",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://metadonors.github.io/odoo.workshop/inheritance/estendere_viste/",
	"title": "Estendere le Viste",
	"tags": [],
	"description": "",
	"content": " Un po\u0026rsquo; di teoria Le viste Form, List e Search sono definite utilizzando la struttura XML arch. Per estenderle dobbiamo modificare quelle definizioni XML e farlo significa localizzare i tag XML che vogliamo cambiare e introdurre le nostre modifiche in quei punti.\nCominciamo subito con un esempio di una vista che ne estende un\u0026rsquo;altra:\n\u0026lt;record model=\u0026quot;ir.ui.view\u0026quot; id=\u0026quot;todo_task_form_view_inherited\u0026quot;\u0026gt; \u0026lt;field name=\u0026quot;name\u0026quot;\u0026gt;todo.task.form\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026quot;model\u0026quot;\u0026gt;todo.task\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026quot;inherit_id\u0026quot; ref=\u0026quot;todo_task_form_view\u0026quot;/\u0026gt; \u0026lt;field name=\u0026quot;arch\u0026quot; type=\u0026quot;xml\u0026quot;\u0026gt; \u0026lt;!-- ...cerca e modifica i tag XML in questo punto... --\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;/record\u0026gt;  Si nota che l\u0026rsquo;unica differenza dalla dichiarazione di una vista normale è la presenza del compo inherit_id in cui si definisce l\u0026rsquo;identificativo della vista che si vuole estendere.\nIl metodo standard per indicare gli elementi XML da modificare è utilizzare un espressione XPath per identificare un elemento presente nella vista. Una volta identificato si può decidere che tipo di modifica apportare.\nPer fare un esempio, se nel nostro form del modello TodoTask volessimo aggiungere il campo deadline_date prima del campo is_done aggiungeremmo questa righa al nostro campo arch\n\u0026lt;!-- Localizza il campo is_done con xpath e specifica la posizione--\u0026gt; \u0026lt;xpath expr=\u0026quot;//field[@name]='is_done'\u0026quot; position=\u0026quot;before\u0026quot;\u0026gt; \u0026lt;!-- Aggiunge il campo deadline_date in quel determinato punto --\u0026gt; \u0026lt;field name=\u0026quot;deadline_date\u0026quot;/\u0026gt; \u0026lt;/xpath\u0026gt;  XPath è uno strumento molto potente ed espressivo, ma spesso troppo prolisso. In questo esempio, come nella maggior parte dei casi, il nostro intento è quello di localizzare uno specifico tag field all\u0026rsquo;interno della vista, quindi le nostre espressioni xpath saranno spesso molto simili. Per semplificare il lavoro, Odoo fornisce una scorciatoia per questo tipo di espressione:\n\u0026lt;field name=\u0026quot;is_done\u0026quot; position=\u0026quot;before\u0026quot;\u0026gt; \u0026lt;field name=\u0026quot;deadline_date\u0026quot;/\u0026gt; \u0026lt;/field\u0026gt;  Utilizzando xpath possiamo in compenso localizzare quasiasi altro tag all\u0026rsquo;interno della vista come \u0026lt;sheet\u0026gt;, \u0026lt;form\u0026gt;, \u0026lt;group\u0026gt; ma anche i classsici \u0026lt;div\u0026gt;.\nL\u0026rsquo;attributo position può assumere diversi valori:\n after aggiunge all\u0026rsquo;elemnto padre, dopo il nodo indicato beforer aggiunge all\u0026rsquo;elemnto padre, prima il nodo indicato inside aggiunge all\u0026rsquo;interno del nodo indicato (default) replace sostituisce l\u0026rsquo;elemento indicato attributo modifica gli attributi XML dell\u0026rsquo;elemento indicato  Estendere le nostre viste Prima di procedere dobbiamo aggiungere al nostro modulo il file XML che conterrè le definizione delle nostre viste ereditate. Come per il precedente modulo aggiungiamo la cartella views/ e al suo interno creiamo il file todo_task.xml\n todo_user/ models/ __init__.py todo_task.py views/ todo_task.xml __init__.py __manifest__.py  Successivamente dobbiamo dichiarare il nuovo file aggiunto nel manifesto dell\u0026rsquo;applicazione\n{ 'name': 'Multiuser TODO', 'description': 'Estende la Todo app per farla diventare Multi Utente', 'author': 'Metadonors', 'depends': ['todo_app'], # Aggiungiamo questa sezione 'data': [ 'views/todo_task.xml' ] }  Inizializziamo il nostro file todo_task.xml con questo contenuto:\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;odoo\u0026gt; \u0026lt;/odoo\u0026gt;  Estendere la Form View Per mettere insieme quello che abbiamo detto fin\u0026rsquo;ora possiamo procedere a modificare la nostra Form View aggiungendo i campi nuovi e andando a nascondere il campo active. Aggiungiamo quindi la nostra vista ereditata dentro il tag \u0026lt;odoo\u0026gt; del file todo_task.xml:\n\u0026lt;record model=\u0026quot;ir.ui.view\u0026quot; id=\u0026quot;todo_task_form_view_inherited\u0026quot;\u0026gt; \u0026lt;field name=\u0026quot;name\u0026quot;\u0026gt;todo.task.form\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026quot;model\u0026quot;\u0026gt;todo.task\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026quot;inherit_id\u0026quot; ref=\u0026quot;todo_app.todo_task_form_view\u0026quot;/\u0026gt; \u0026lt;!-- ...cerca e modifica i tag XML in questo punto... --\u0026gt; \u0026lt;field name=\u0026quot;arch\u0026quot; type=\u0026quot;xml\u0026quot;\u0026gt; \u0026lt;!-- Dopo il campo 'name' aggiungi il campo 'user_id' --\u0026gt; \u0026lt;field name=\u0026quot;name\u0026quot; position=\u0026quot;after\u0026quot;\u0026gt; \u0026lt;field name=\u0026quot;user_id\u0026quot;/\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;!-- prima del campo 'is_done' aggiungi il campo 'deadline_date' --\u0026gt; \u0026lt;field name=\u0026quot;is_done\u0026quot; position=\u0026quot;before\u0026quot;\u0026gt; \u0026lt;field name=\u0026quot;deadline_date\u0026quot;/\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;!-- modifica gli attributi del campo 'active' per rederlo invisibile --\u0026gt; \u0026lt;field name=\u0026quot;active\u0026quot; positiion=\u0026quot;attributes\u0026quot;\u0026gt; \u0026lt;attribute name=\u0026quot;invisible\u0026quot;\u0026gt;1\u0026lt;/attribute\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;/record\u0026gt;  Una volta effettuata la modifica possiamo aggiornare il nostro modulo con\n $ docker-compose run odoo upgrade todo_user  ricaricare la pagine nel nostro browser e ottenere questo form\nEstendere la List View Nello stesso modo procediamo a modificare la List View andando ad aggiungere il campo dell\u0026rsquo;incaricato subito dopo il nome del task. Per farlo aggiungiamo un altro record al nostro file todo_task.xml\n\u0026lt;record model=\u0026quot;ir.ui.view\u0026quot; id=\u0026quot;todo_task_tree_view_inherited\u0026quot;\u0026gt; \u0026lt;field name=\u0026quot;name\u0026quot;\u0026gt;todo.task.tree\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026quot;model\u0026quot;\u0026gt;todo.task\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026quot;inherit_id\u0026quot; ref=\u0026quot;todo_app.todo_task_tree_view\u0026quot;/\u0026gt; \u0026lt;!-- ...cerca e modifica i tag XML in questo punto... --\u0026gt; \u0026lt;field name=\u0026quot;arch\u0026quot; type=\u0026quot;xml\u0026quot;\u0026gt; \u0026lt;!-- Dopo il campo 'name' aggiungi il campo 'user_id' --\u0026gt; \u0026lt;field name=\u0026quot;name\u0026quot; position=\u0026quot;after\u0026quot;\u0026gt; \u0026lt;field name=\u0026quot;user_id\u0026quot;/\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;/record\u0026gt;  aggiorniamo il nostro modulo con\n $ docker-compose run odoo upgrade todo_user  ricaricare la pagine nel nostro browser e visualizziamo la lista\nEstendere la Search View Per finire aggiungiamo la possibilita di ricercare per utente nella nostra Search View\n\u0026lt;record model=\u0026quot;ir.ui.view\u0026quot; id=\u0026quot;todo_task_search_view_inherited\u0026quot;\u0026gt; \u0026lt;field name=\u0026quot;name\u0026quot;\u0026gt;todo.task.search\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026quot;model\u0026quot;\u0026gt;todo.task\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026quot;inherit_id\u0026quot; ref=\u0026quot;todo_app.todo_task_search_view\u0026quot;/\u0026gt; \u0026lt;!-- ...cerca e modifica i tag XML in questo punto... --\u0026gt; \u0026lt;field name=\u0026quot;arch\u0026quot; type=\u0026quot;xml\u0026quot;\u0026gt; \u0026lt;field name=\u0026quot;name\u0026quot; position=\u0026quot;after\u0026quot;\u0026gt; \u0026lt;!-- Aggiungi il campo 'user_id' all ricerca libera--\u0026gt; \u0026lt;field name=\u0026quot;user_id\u0026quot;/\u0026gt; \u0026lt;!-- Aggiungi il filtro predefinito \u0026quot;I miei task\u0026quot; --\u0026gt; \u0026lt;filter name=\u0026quot;filter_my_tasks\u0026quot; string=\u0026quot;I miei Tasks\u0026quot; domain=\u0026quot;[('user_id','=',uid)]\u0026quot; /\u0026gt; \u0026lt;!-- Aggiungi il filtro predefinito \u0026quot;Task non assegnati\u0026quot; --\u0026gt; \u0026lt;filter name=\u0026quot;filter_not_assigned\u0026quot; string=\u0026quot;Non assegnati\u0026quot; domain=\u0026quot;[('user_id','=', False)]\u0026quot; /\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;/record\u0026gt;  aggiorniamo il nostro modulo con\n $ docker-compose run odoo upgrade todo_user  ricaricare la pagine nel nostro browser e controlliamo come e\u0026rsquo; cambiato il form di ricerca\nContinua Ora possiamo continuare andando a vedere come modificare i dati dei moduli\n"
},
{
	"uri": "https://metadonors.github.io/odoo.workshop/first_app/prime_viste/",
	"title": "Le viste",
	"tags": [],
	"description": "",
	"content": " Le viste descrivono l\u0026rsquo;interfaccia utente. Ogni vista è strutturata in un file XML, che è utilizzato dal client web per generare le pagine HTML in grado di gestire i dati generati dal nostro backend.\nNelle viste abbiamo dei menu item che ci permettono di attivare funzionalità o navigazione scatenando delle actions. Per esempio, il menu item Users processa una action chiamata anchessa Users, che renderizza le viste per la gestione degli utenti.\nPer ogni modello sono disponibili diversi tipi di viste, le principali che utilizzeremo sono: list view, form view e search view.\nCreazione del MenuItem e della ActWindow Generalemente le viste sono raggruppate nella cartella views all\u0026rsquo;interno del modulo. Prima della creazione della vista vera e propria, abbiamo bisogno di un menu item che ci permetta di navigare alla nostra applicazione Todo Task. Per farlo creiamo la cartella views e al suo interno il file todo_menu.xml ottenendo la seguente struttura\ntodo_app/ models/ __init__.py todo_model.py views/ todo_menu.xml __init__.py __manifest__.py  e aggiungiamo il seguente contenuto che definisce l\u0026rsquo;oggetto menu e l\u0026rsquo;azione necessaria per navigare verso l\u0026rsquo;applicazione:\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;odoo\u0026gt; \u0026lt;!-- Azione che apre la vista list Todo Task --\u0026gt; \u0026lt;act_window id=\u0026quot;action_todo_task\u0026quot; name=\u0026quot;ToDo Task\u0026quot; res_model=\u0026quot;todo.task\u0026quot; view_mode=\u0026quot;tree,form\u0026quot; /\u0026gt; \u0026lt;!-- Oggetto menu che apre la lista dei Todo --\u0026gt; \u0026lt;menuitem id=\u0026quot;menu_todo_task\u0026quot; name=\u0026quot;Todos\u0026quot; action=\u0026quot;action_todo_task\u0026quot; /\u0026gt; \u0026lt;/odoo\u0026gt;  Questo piccolo pezzo di codice è un file Odoo data. Odoo lo legge e aggiunge nel suo database queste definizioni. Nello specifico abbiamo definito:\n un elemento \u0026lt;act_window\u0026gt; che definice un\u0026rsquo;azione client side che apre le viste relative al modello di nome todo.task con le viste tree e form abilitate\n un elemento \u0026lt;menuitem\u0026gt; che definisce un menu primario che una volta cliccato scatena l\u0026rsquo;azione con id _action_todotask\n  Entrambi questi elementi hanno un attributo id, spesso chiamato XML ID, che è molto importante: è utilizzato nel modulo e all\u0026rsquo;esterno del modulo per fare riferimento a quell\u0026rsquo;oggetto specifico. Quindi, per esempio, per invocarlo, modificarlo o eliminarlo. Nel caso specifico il \u0026lt;menuitem\u0026gt; utilizza l\u0026rsquo;id della \u0026lt;act_window\u0026gt; per invocarla.\nCon viste Tree in Odoo si intendo i listati. Vengono chiamati tree per ragioni storiche anche se attualmente non hanno più un comportamento da struttura ad albero se non in rari casi, come i raggruppamenti, dove permettono di visualizzare i dati su due livelli.\n Come per i modelli, Odoo attualmente non sa dell\u0026rsquo;esistenza del file che abbiamo appena creato. Per dichiararlo dobbiamo aggiungere al file __manifest__.py l\u0026rsquo;attributo data che elenca tutte le risorse (codice Python escluso) disponibili in questo modulo.\nQuindi aprimo il file __manifest__.py e modifichiamolo di conseguenza:\n{ 'name': 'Applicazione TODO', 'description': 'Gestisci i tuoi TODO', 'author': 'Fabrizio Arzeni', 'depends': ['base'], 'application': True, # Aggiungiamo questa parte 'data': [ 'views/todo_menu.xml' ] }  Ogni definizione che aggiungiamo in file XML viene letta e aggiunta nel database da Odoo in fase di upgrade del modulo. Quando aggiungiamo oggetti dobbiamo effettuare un upgrade manuale del modulo per renderli disponibili. In modalita sviluppo del backend (\u0026ndash;dev=all) le modifiche invece vengono lette automaticamente ed è sufficiente ricaricare la pagina. In produzione invece è sempre necessario effettuare l\u0026rsquo;upgrade del modulo.\n A questo punto non ci resta che effettuare l\u0026rsquo;upgrade del modulo e ricaricare la nostra pagina.\n$ docker-compose run odoo upgrade todo_app  Se abbiamo fatto tutto correttamente, dovremmo vedere:\nCreazione delle vista Form Premendo il tasto Create, Odoo ci presenta un Form di default basato sulla definizione dei campi che gli abbiamo dato. Il form presentato è molto basilare, presenta semplicemente i campi definiti, nelle applicazioni reali andremo a creare un form specializzato per ogni tipo di modello.\nLe viste Form in odoo hanno un duplice utlizzo: modifica e visualizzazione dei dati. Quindi definendo una vista Form stiamo nello stesso momento creando due schermate: quella utilizzata per visualizzare i dati di un record e quella per modificarli. Rimane comunque possibile modificare questo comportamento specificando viste distinte per la visualizzazione e la modifica.\n Per farlo dobbiamo aggiungere, dichiarandolo in un file XML Odoo data, un oggetto di tipo ir.ui.view. Quindi creiamo un nuovo file XML all\u0026rsquo;interno della cartella view di nome todo_views.xml e otteniamo:\ntodo_app/ models/ __init__.py todo_model.py todo_views.py views/ todo_menu.xml todo_views.xml __init__.py __manifest__.py  All\u0026rsquo;interno di questo file aggiungiamo il seguente contenuto:\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;odoo\u0026gt; \u0026lt;record model=\u0026quot;ir.ui.view\u0026quot; id=\u0026quot;todo_task_form_view\u0026quot;\u0026gt; \u0026lt;field name=\u0026quot;name\u0026quot;\u0026gt;todo.task.form\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026quot;model\u0026quot;\u0026gt;todo.task\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026quot;arch\u0026quot; type=\u0026quot;xml\u0026quot;\u0026gt; \u0026lt;form string=\u0026quot;ToDo Task Form\u0026quot;\u0026gt; \u0026lt;group\u0026gt; \u0026lt;field name=\u0026quot;name\u0026quot;/\u0026gt; \u0026lt;field name=\u0026quot;is_done\u0026quot;/\u0026gt; \u0026lt;field name=\u0026quot;active\u0026quot; readonly=\u0026quot;1\u0026quot;/\u0026gt; \u0026lt;/group\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;/record\u0026gt; \u0026lt;/odoo\u0026gt;  Questo codice aggiungne una vista con l\u0026rsquo;idendificativo _todo_task_formview. L\u0026rsquo;attributo model indica a Odoo che deve usare questa vista sugli oggetti di tipo todo.task. L\u0026rsquo;attributo arch indica il contenuto effetivo della vista e il tag form specifica che la vista definita è di tipo Form View.\nCome per il menu, dobbiamo aggiungere questo file al manifesto del modulo per far si che Odoo lo riconosca e lo carichi. Apri quindi il __manifest__.py modficalo come segue:\n{ 'name': 'Applicazione TODO', 'description': 'Gestisci i tuoi TODO', 'author': 'Fabrizio Arzeni', 'depends': ['base'], 'application': True, 'data': [ 'views/todo_menu.xml', 'views/todo_views.xml', # Aggiungiamo questa riga ] }  Una volta fatto possimo effettuare l\u0026rsquo;upgrade del modulo e aggiornare la pagina.\n$ docker-compose run odoo upgrade todo_app  Se tutto è andato bene otterremo una pagina di questo genere:\nChe ci permetti di effettuare le basiche operazioni CRUD sui nostri modelli. Ma vediamo come possiamo migliorare ancora un po\u0026rsquo; la visualizzazione dei dati.\nSebbene ci sia libertà nella strutturazione delle pagine in Odoo, ci sono alcune linee guida che è utile sapere (e seguire) per rendere più semplice la vita agli utenti.\nLa struttura delle Form View di Odoo è piuttosto standard e prende ispirazione dai fogli di carta. La pagina è suddivisa in due parti: - un tag \u0026lt;header\u0026gt; che fa riferimento alla barra orizzontale in alto, dove solitamente si posizionano i bottoni di azione e gli stati dell\u0026rsquo;oggetto - un tag \u0026lt;sheet\u0026gt; che rappresenta la parte centrale della pagina (il foglio di carta), dove vengono rappresentati i dati.\nUn altro elemento utile nei from è il tag \u0026lt;group\u0026gt; che permette di ragguppare i campi, suddividendoli su più colonne.\nPer creare queste due aree e aggiungere un paio di bottoni modifichiamo il nostro file todo_views.xml, aggiungendo queste due aree:\n\u0026lt;form string=\u0026quot;ToDo Task Form\u0026quot;\u0026gt; \u0026lt;!-- Aggiungiamo l'header, dove posizioneremo i bottoni--\u0026gt; \u0026lt;header\u0026gt; \u0026lt;!-- Aggiungiamo un pulsante per modificare lo stato Fatto del task --\u0026gt; \u0026lt;button name=\u0026quot;do_toggle_button\u0026quot; type=\u0026quot;object\u0026quot; string=\u0026quot;Toggle Done\u0026quot; class=\u0026quot;oe_highlight\u0026quot;/\u0026gt; \u0026lt;!-- Aggiungiamo un pulsante per rimuovere i task in stato fatto --\u0026gt; \u0026lt;button name=\u0026quot;do_clear_done\u0026quot; type=\u0026quot;object\u0026quot; string=\u0026quot;Clear All Done\u0026quot; class=\u0026quot;oe_highlight\u0026quot;/\u0026gt; \u0026lt;/header\u0026gt; \u0026lt;!-- Aggiungiamo lo sheet per incapsulare il contenuto --\u0026gt; \u0026lt;sheet\u0026gt; \u0026lt;!-- Raggruppiamo i campi su due colonne e assegnamo un identificativo ai vari gruppi --\u0026gt; \u0026lt;group name=\u0026quot;group_top\u0026quot;\u0026gt; \u0026lt;group name=\u0026quot;group_left\u0026quot;\u0026gt; \u0026lt;field name=\u0026quot;name\u0026quot;/\u0026gt; \u0026lt;/group\u0026gt; \u0026lt;group name=\u0026quot;group_right\u0026quot;\u0026gt; \u0026lt;field name=\u0026quot;is_done\u0026quot;/\u0026gt; \u0026lt;field name=\u0026quot;active\u0026quot; readonly=\u0026quot;1\u0026quot;/\u0026gt; \u0026lt;/group\u0026gt; \u0026lt;/group\u0026gt; \u0026lt;/sheet\u0026gt; \u0026lt;/form\u0026gt;  In questo caso, non avendo aggiunto record nel data file sarà sufficiente ricaricare la pagina per vedere le modifiche\n Ricaricando la pagina vediamo che è stata aggiunta una barra in alto contenente i due bottoni e che il form è stato racchiuso in un box.\nCreazione delle vista List Anche le viste Tree (i listati) possono - e devono - essere personalizzate in base al modello, per farlo si va a definire un altro record nel file delle viste del modello come nel cado delle Form View, ma questa volta utilizzando il tag \u0026lt;tree\u0026gt;.\nAprimo quindi il file todo_views.xml e aggiungiamo:\n\u0026lt;record model=\u0026quot;ir.ui.view\u0026quot; id=\u0026quot;todo_task_tree_view\u0026quot;\u0026gt; \u0026lt;field name=\u0026quot;name\u0026quot;\u0026gt;todo.task.tree\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026quot;model\u0026quot;\u0026gt;todo.task\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026quot;arch\u0026quot; type=\u0026quot;xml\u0026quot;\u0026gt; \u0026lt;tree decoration-muted=\u0026quot;is_done==True\u0026quot;\u0026gt; \u0026lt;field name=\u0026quot;name\u0026quot;/\u0026gt; \u0026lt;field name=\u0026quot;is_done\u0026quot;/\u0026gt; \u0026lt;/tree\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;/record\u0026gt;  Con questo codice creeremo un listato con due colonne. Abbiamo anche utilizzato una finezza, nel tag tree utlizziamo l\u0026rsquo;attributo decoration-{$name} della vista. Per maggiori informazioni leggi la documentazione ufficiale di Odoo a riguardo.\nSe tutto è andato bene dovremo ottenere questa schermata:\nCreazione delle vista Search Le Search View sono leggermente differenti da quelle che abbiamo visto finora. La grossa differenza è che in questo caso non abbiamo una schermata dedicata alla ricerca, ma con la definizione di una Search View andiamo a modificare il blocco di ricerca presente in alto a destra nelle Tree View.\nPer farlo aggiungiamo un altro record al file todo_views.xml come di seguito:\n\u0026lt;record model=\u0026quot;ir.ui.view\u0026quot; id=\u0026quot;todo_task_search_view\u0026quot;\u0026gt; \u0026lt;field name=\u0026quot;name\u0026quot;\u0026gt;todo.task.search\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026quot;model\u0026quot;\u0026gt;todo.task\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026quot;arch\u0026quot; type=\u0026quot;xml\u0026quot;\u0026gt; \u0026lt;search\u0026gt; \u0026lt;field name=\u0026quot;name\u0026quot;/\u0026gt; \u0026lt;filter string=\u0026quot;Not Done\u0026quot; domain=\u0026quot;[('is_done','=',False)]\u0026quot;/\u0026gt; \u0026lt;filter string=\u0026quot;Done\u0026quot; domain=\u0026quot;[('is_done','!=',False)]\u0026quot;/\u0026gt; \u0026lt;/search\u0026gt; \u0026lt;/field\u0026gt; \u0026lt;/record\u0026gt;  Il tag \u0026lt;field\u0026gt; definisce i campi su cui è possibile effettuare la ricerca digitando nel box testuale. I tag \u0026lt;filter\u0026gt; aggiungono invece dei filtri predefiniti nel menu dei filtri. Vedremo successivamente qual\u0026rsquo;è il dignificato dell\u0026rsquo;attributo domain.\nContinua A questo punto siamo in grado di creare, visualizzare, cancellare, listare, cercare e filtrare i dati relativi al nostro nuovo modello, non ci rimane che aggiungere della logica applicativa che ci permetta di effettuare operazioni più strutturate.\n"
},
{
	"uri": "https://metadonors.github.io/odoo.workshop/basics/concetti/",
	"title": "Concetti Base",
	"tags": [],
	"description": "",
	"content": " Prima di cominciare è necessario affrontare un po\u0026rsquo; di teoria che sta alla base del framework Odoo. Odoo è un framework applicativo modulare, i suoi principali componenti sono i moduli e le applicazioni.\nModuli I moduli sono i componenti essenziali che possono essere aggiunti a Odoo. Ogni modulo può implementare nuove funzionalità oppure modificare quelle esistenti. Ogni modulo è costituito da una cartella contenente un file __manfifest.py__ più altri file che implementano le sue funzionalità.\nApplicazioni Le applicazioni sono moduli di ordine maggiore, che implementano funzionalità a più alto livello o sempliccemente più complesse. Sono gli elementi essenziali dell\u0026rsquo;aspetto funzionale, come per esempio l\u0026rsquo;applicazione CRM o Contabilità e sono a loro volta basate sulle funzionalità di tanti moduli.\nSe state implementando un modulo complesso che aggiunge funzionalità specifiche a Odoo è probabile che sia un applicazione. Se state aggiungendo o modificando alcuni semplici aspetti invece è probabile che stiate sscrivendo un modulo.\nTecnicamente non c\u0026rsquo;è nessuna differenza fra i due, semplicemente le applicazioni vengono mostrate nell\u0026rsquo;elenco delle App disponibili all\u0026rsquo;utente.\nAdattare il sistema Generalmmente per adattare Odoo alle diverse esigenze non si modifica mai il codice esistente. Piuttosto si creano nuovi moduli che vanno a innestarsi sugli esistenti per modificare le funzionailtà.\nIn questo corso creeremo un applicazione con pochissime dipendenze, per questioni pratiche, ma nei casi reali è molto più probabile andare a lavorare sui moduli core di odoo oppure su moduli terzi resi disponibili da altri sviluppatori.\nInstalliamo il nostro primo modulo Per fare un esempio, procediamo all\u0026rsquo;installazione di un modulo fornito dalla comunità. Installeremo un modulo che estende la ui del nostro backend rendendola più simile alla versione di Odoo Enterprise.\nIl modulo è già stato pacchettizzato e inserito nel codice, possiamo quindi procedere con l\u0026rsquo;installazione da interfaccia web.\nAndiamo su http://localhost mettiamo username e password e accediamo alla lista delle app.\nDeselezioniamo il filtro \u0026ldquo;Apps\u0026rdquo; dalla barra di ricerca e inseriamo la stringa \u0026ldquo;Material\u0026rdquo;\nClicchiamo su Install e\u0026hellip;fatto. Abbiamo installato il nostro primo modulo e subito il nostro Odoo ha un look più moderno.\nContinua Ora possiamo andare a creare la nostra prima applicazione\n"
},
{
	"uri": "https://metadonors.github.io/odoo.workshop/inheritance/",
	"title": "Estendere i moduli",
	"tags": [],
	"description": "",
	"content": " Capitolo 3 ESTENDERE L\u0026rsquo;ESISTENTE La vera potenza di Odoo si esprime nel riutilizzo delle applicazioni e dei moduli esistenti e nell\u0026rsquo;adattarli alle esigenze specifiche del momento. Vediamo ora come è strutturato il meccanismo di eredità che il framework ci offre.\n"
},
{
	"uri": "https://metadonors.github.io/odoo.workshop/inheritance/estendere_dati/",
	"title": "Estendere i Dati",
	"tags": [],
	"description": "",
	"content": " A differenza delle viste i file xml contenenti dati, come i menuitem oppure le security rules, non hanno l\u0026rsquo;elemento arch e non possono quindi essere modificati utilizzanto XPath. Ma possono comunque essere modificati, rimpiazzando i valori contenuti nei loro campi.\nOgni volta che dichiariamo un \u0026lt;record id=\u0026ldquo;x\u0026rdquo; model=\u0026ldquo;y\u0026rdquo;\u0026gt; Odoo effettua una insert o una update nel database, quindi riutilizzando gli stessi id possiamo andare ad aggiornare i dati inseriti dai moduli genitori.\nVediamo nel dettaglio cosa significa.\nModificare i Menuitem e le Action Per fare un esempio modifichiamo l\u0026rsquo;elemento del menu creato dalla todo_app andando a modificare la sua stringa in I miei Todo. Per farlo possiamo aggiungere in fondo al file views/todo_task.xml\n\u0026lt;!-- Modifica l'elemento del menu --\u0026gt; \u0026lt;record id=\u0026quot;todo_app.menu_todo_task\u0026quot; model=\u0026quot;ir.ui.menu\u0026quot;\u0026gt; \u0026lt;field name=\u0026quot;name\u0026quot;\u0026gt;I miei Todo\u0026lt;/field\u0026gt; \u0026lt;/record\u0026gt;  Possiamo anche modificare la action che abbiamo creato precedentemente. Le action possono avere un parametro context opzionale che va a modificare il comportamento della stessa, per esempio aggiungendogli dei valori di default che verranno utilizzati per popolare field o filters. Quello che faremo sarà modificare la action per far si che venga visualizzata la pagina della lista Todo con il filtro I miei Task preselezionato. Aggiungiamo quindi in fondo al file views/todo_task.xml\n\u0026lt;!-- Modifica la action --\u0026gt; \u0026lt;record id=\u0026quot;todo_app.action_todo_task\u0026quot; model=\u0026quot;ir.actions.act_window\u0026quot;\u0026gt; \u0026lt;field name=\u0026quot;context\u0026quot;\u0026gt;{'search_default_filter_my_tasks': True}\u0026lt;/field\u0026gt; \u0026lt;/record\u0026gt;  Se abbiamo fatto tutto correttamente dopo un upgrade del modulo\n $ docker-compose run odoo upgrade todo_user  dovremmo vedere:\nModficare le regole di sicurezza La nostra applicazione precedente permette agli utenti di vedere solo i Task creati da loro stessi. Ora vogliamo che i task siano accessibili all\u0026rsquo;incaricato e a tutti i follower del task. Come per i menuitem e le actions andremo a sovrascriere la regola precedentemente creata modificando il suo campo domain_force.\nEssendo una regola di sicurezza, per convenzione, la metteremo nella sottocartella security/ in un file che chiameremo todo_access_rules.xml\n todo_user/ models/ __init__.py todo_task.py views/ todo_task.xml security/ todo_access_rules.xml __init__.py __manifest__.py  che andremo successivamente ad aggiungere anche al manifesto dell\u0026rsquo;applicazione:\n{ 'name': 'Multiuser TODO', 'description': 'Estende la Todo app per farla diventare Multi Utente', 'author': 'Metadonors', 'depends': ['todo_app'], 'data': [ 'security/todo_access_rules.xml', # \u0026lt;-- Aggiungiamo questa riga 'views/todo_task.xml' ] }  Il contenuto del file per la regola di accesso sarà quindi il seguente:\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;odoo\u0026gt; \u0026lt;data noupdate=\u0026quot;1\u0026quot;\u0026gt; \u0026lt;record model=\u0026quot;ir.rule\u0026quot; id=\u0026quot;todo_app.todo_task_user_rule\u0026quot;\u0026gt; \u0026lt;field name=\u0026quot;name\u0026quot;\u0026gt;todo.task.user.rule\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026quot;model_id\u0026quot; ref=\u0026quot;model_todo_task\u0026quot;/\u0026gt; \u0026lt;field name=\u0026quot;groups\u0026quot; eval=\u0026quot;[4, ref('base.group_user')]\u0026quot;/\u0026gt; \u0026lt;field name=\u0026quot;domain_force\u0026quot;\u0026gt; ['|', ('user_id', 'in', (user.id, False)), ('message_follower_ids', 'in', [user.partner_id.id])] \u0026lt;/field\u0026gt; \u0026lt;/record\u0026gt; \u0026lt;/data\u0026gt; \u0026lt;/odoo\u0026gt;  Continua Abbiamo parlato di Follower, perchè mettevamo le basi per la prossima funzionalità: aggiungere un pizzico di social networking dando agli utenti la possibilità di commentare e seguire l\u0026rsquo;evoluzione dei nostri task. Questa è una funzionalità già presente in Odoo implementarla ci permette di vedere come riutilizzare il codice di terzi moduli\n"
},
{
	"uri": "https://metadonors.github.io/odoo.workshop/first_app/prima_funzione/",
	"title": "La logica",
	"tags": [],
	"description": "",
	"content": " A questo punto è arrivato il momento di aggiungere della logica applicativa al nostro modulo. Per farlo possiamo sfruttare i bottoni che abbiamo aggiunto nella sezione precedente relativa alle viste.\nAggiungere la logica applicativa Nella precedente sezione abbiamo aggiunto due bottoni per invocare delle funzioni Python sul nostro backend. Riporto qui il codice interessato per comodità.\n\u0026lt;button name=\u0026quot;do_toggle_button\u0026quot; type=\u0026quot;object\u0026quot; string=\u0026quot;Toggle Done\u0026quot; class=\u0026quot;oe_highlight\u0026quot;/\u0026gt;  In questo tag stiamo definendo alcuni attributi, vediamoli nel dettaglio:\n string è la stringa che verrà visualizzata all\u0026rsquo;utente all\u0026rsquo;interno del bottone class è la classe CSS che verrà applicata al bottone (in questo caso ne applichiamo una predefinita in Odoo) type è il tipo di azione che deve essere scatenata quando il bottone viene premuto, può essere valorizzato come  object per invocare un metodo del modello action per invocare un\u0026rsquo;azione generica (come quella che abbiamo utilizzato per accedere all\u0026rsquo;applicazione)  name nel caso in cui type=object name rappresenta il nome del metodo che verrà invocato, in questo caso do_toggle_button  Per altre informazioni fai riferimento alla documentazione ufficiale di Odoo\nQuindi avendo definito un bottone con type=object e name=do_toggle_button non ci rimane che aggiungere questo metodo alla classe Python che rappresenta il modello. Apriamo quindi il file models/todo_model.py e aggiungiamo un metodo alla classe:\n# Nell'intestazione modifichiamo l'import aggiungendo api from odoo import models, fields, api  # Nel corpo della classe aggiungiamo il metodo @api.multi def do_toggle_button(self): for todo in self: todo.is_done = not todo.is_done  Poche righe, ma tanti concetti.\nPrima di tutto il decoratore @api.multi. Odoo è un software scritto con una logica API first, che significa che il codice che scrivete nel backend (in Python) è completamente slegato da quello che avviene nel frontend (che invece è scritto in Javascript). Ogni funzione che volete esporre al frontend deve essere esposta come un API JSONRPC (un protocollo RPC di qui potete trovare maggiori infomazioni su internet).\nIl decoratore @api.multi dice ad Odoo che volete esporre il metodo al frontene (@api) e che quel metodo puo essere eseguito su uno o più record alla volta (multi). Quindi potete invocare questo metodo su un solo record todo in una chiamata come su 100 o 1000.\nEssendo un metodo multi il self dell\u0026rsquo;oggetto rappresenta non un istanza sola, ma un RecordSet che è una struttura di odoo che raggruppa oggetti dello stesso tipo e ha il principale scopo di eseguire operazioni in batch ottimizzate su molti oggetti. Quindi ciclando sul self stiamo andando a lavorare su ogni record presente in questa chiamata.\nPer l\u0026rsquo;altro bottone invece:\n\u0026lt;button name=\u0026quot;do_clear_done\u0026quot; type=\u0026quot;object\u0026quot; string=\u0026quot;Clear All Done\u0026quot; class=\u0026quot;oe_highlight\u0026quot;/\u0026gt;  Vediamo che abbiamo dichiarato che vogliamo invocare il metodo do_clear_done che andiamo a implementare nel nostro models/todo_models.py come segue\n@api.model def do_clear_done(self): dones = self.search([ ('is_done', '=', True) ]) dones.write({ 'active': False })  Questo metodo invece viene chiamato con il decoratore @api.model che invece identifica o un oggetto in particolare oppure nessuno. Con il metodo search andriamo a cercare i todo che ci interessano passandogli un domain per la ricerca e infine aggiorniamo il loro stato come inattivo.\nI domain sono il principale metodo per effettuare ricerche nel database usando il framework di Odoo. Li vediamo pi\\ nel dettaglio successivamente.\nContinua Con quest\u0026rsquo;ultimo passaggio abbiamo terminato la nostra panoramica delle funzionalità base di un modulo Odoo. Rimane una piccola macchia che ci permette però di andare a guardare un ultimo aspetto riguardante i nostri modelli.\nSe ci fate caso, avviando il server di odoo, viene visualizzato un WARNING di questo tipo:\nWARNING demo odoo.modules.loading: The model todo.task has no access rules, consider adding one. E.g. access_todo_task,access_todo_task,model_todo_task,,1,0,0,0  La ragione di questo avviso è legata al meccanismo delle regole di accesso ai dati di Odoo, vediamo come funzionano e come risolvere nella prossima sezione.\n"
},
{
	"uri": "https://metadonors.github.io/odoo.workshop/models/",
	"title": "I Modelli",
	"tags": [],
	"description": "",
	"content": " Chapter 2 Modelli Odoo è un framework MVC, i Modelli sono la M del paradigma e ci permettono di rappresentare i nostri dati in maniera strutturata, come per esempio i Prodotti, le Vendite, le Fatture o i Clienti. Vediamo che srtumenti abbiamo per strutturarli al meglio.\n"
},
{
	"uri": "https://metadonors.github.io/odoo.workshop/inheritance/aggiungere_funzionalita/",
	"title": "Aggiungere funzionalità",
	"tags": [],
	"description": "",
	"content": " Finora abbiamo visto come estendere applicazioni esistenti aggiungendo funzionalità create da noi. Ma Odoo permette di fare molto di più: possiamo aggiungere funzionalità implementate di moduli scritti da altre persone.\nNel nostro caso vogliamo aggiugere la possibilità per gli utenti di commentare i task e di poterli seguire, alla maniera di Twitter. Questa funzionalità in Odoo è implementata nel modulo mail, più peccificatamente nel modello mail.thread di quel modulo.\nPer aggiungerlo al nostro modello todo.task dobbiamo procede in questo modo:\n Aggiungere il modulo mail alle nostre dipendenze Aggiungere la classe mail.thred a quelle che eredita il nostro modello todo.task Aggiungere i campi necessari nella nostra vista Modficare le regole di accesso per questa funzionalità (lo abbiamo già fatto nella sezione precedente)  Modificare le dipendenze Apriamo il nostro file di manfiesto e modifichiamolo come segue:\n{ 'name': 'Multiuser TODO', 'description': 'Estende la Todo app per farla diventare Multi Utente', 'author': 'Metadonors', 'depends': [ 'todo_app', 'mail' # \u0026lt;-- Aggiungiamo la dipendenza ], 'data': [ 'security/todo_access_rules.xml', # \u0026lt;-- Aggiungiamo questa riga 'views/todo_task.xml' ] }  Aggiungere la classe al modello Per aggiungere la classe al modello procediamo nella stessa maniera con cui abbiamo ereditato il modello esteso dal modello base. Andiamo ad aggiungere all\u0026rsquo;attributo _inherit il modello mail.thread\nApriamo il nostro file models/todo_task.py\nclass TodoTask(models.Model): _name = 'todo.task' _inherit = ['todo.task', 'mail.thread']  Con questa semplice modifica il nostro modello thread acquisterà tutta la logica che gli serve per far funzionare la messaggistica. C\u0026rsquo;è anche da notare che mettendo due dipendenze siamo obbligati anche a specificare quale deve essere il nome del modello principale da cui ereditiamo, per questo aggiungiamo ancche l\u0026rsquo;attributo _name.\nIl modello mail.thread è un Abstract Class, che significa che non ha una tabella sua di riferimento. Può essere ssolo utiilizzato in altri modelli e va a estendere le loro funzionalità. Quindi, nella pratica, aggiungendolo andrà a modificare direttamente la tabella originale e aggiungerà al modello i metodi necessari alle sue funzionalità. Per maggiori infomazioni consultate la documentazione ufficiale di Odoo.\n Aggiungere i campi necessari alla vista A questo punto non ci rimane che aggiungere il widget delle funzionalità mail al fondo della nostra Form View del modello. Apriamo il file views/todo_task.xml e aggiungiamo nell\u0026rsquo;attributo arch questo codice XML\n\u0026lt;sheet position=\u0026quot;after\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;oe_chatter\u0026quot;\u0026gt; \u0026lt;field name=\u0026quot;message_follower_ids\u0026quot; widget=\u0026quot;mail_followers\u0026quot;/\u0026gt; \u0026lt;field name=\u0026quot;message_ids\u0026quot; widget=\u0026quot;mail_thread\u0026quot;/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/sheet\u0026gt;  Se ci fate caso i due campi message_followers_ids e message_ids non sono stati implementati esplicitamente da noi ma vengono ereditati dalla classe mail.thread.\nA questo punto non ci resta che effettuare l\u0026rsquo;upgrade del nostro modello\n $ docker-compose run odoo upgrade todo_user  ricaricare la pagina e cominciare ad aggiungere commenti\nContinua Il nostro upgrade del modulo base è finito, a questo punto possiamo andare a guardare più nel dettaglio cosa ci offre il framework Odoo. Cominciamo ad analizzare i Modelli\n"
},
{
	"uri": "https://metadonors.github.io/odoo.workshop/first_app/controllo_accessi/",
	"title": "Controllo Accessi",
	"tags": [],
	"description": "",
	"content": " Nella scorsa sezione abbiamo terminato la creazione del nostro modulo base. Al termine abbiamo notato che Odoo si lamentava dicendo che non abbiamo specificato delle regole di accesso per il modello da noi creato\nWARNING demo odoo.modules.loading: The model todo.task has no access rules, consider adding one. E.g. access_todo_task,access_todo_task,model_todo_task,,1,0,0,0  In Odoo tutti i modelli devono avere delle regole di accesso specificate, in caso contrario solo l\u0026rsquo;utente admin potrà accedere ai dati relativi a quel modello.\nCi sono due tipi di controlli di accesso disponibili: access control list e row level access control\n access control list sono le regole principale e obbligatorie da definire per modello, indicano l\u0026rsquo;accesso generico in termini booleani SI/NO che i gruppi di utenti hanno rispetto ai dati del modello declinati in lettura, scrittura, creazione e cancellazione row level access control sono le regole che a seguito delle access control list vengono applicate in termini di riga. Per esempio: tutti i dipendenti possono creare oggetti Todo ma possono visualizzare e utilizzare sono quelli creati da loro.  Access Control List Per farci un\u0026rsquo;idea di come sono strutturate queste regole, entriamo in modalità sviluppo e andiamo in:\nSettings -\u0026gt; Technical -\u0026gt; Security -\u0026gt; Access Control List\nCi troveremo di fronte a una pagina come questa:\nQuindi quello che dovremo fare è aggiungere un Odoo data file, come per le viste, contenente le informazioni che voglioamo caricare in questa tabella relative ai nostri modelli.\nSolitamente le regole di accesso vengono inserite nella cartella security all\u0026rsquo;interno del modulo in cui stiamo lavorando. Quindi creaiamola e al suo interno aggiungiamo un file todo_model_acl.xml ottenendo questa struttura\ntodo_app/ models/ __init__.py todo_model.py todo_views.py views/ todo_menu.xml todo_views.xml security/ todo_model_acl.xml __init__.py __manifest__.py  All\u0026rsquo;interno del file todo_model_acl.xml andiamo poi a definire i dati che regoleranno l\u0026rsquo;acl in questione nel seguente modo\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;utf-8\u0026quot;?\u0026gt; \u0026lt;odoo\u0026gt; \u0026lt;data noupdate=\u0026quot;1\u0026quot;\u0026gt; \u0026lt;record model=\u0026quot;ir.model.access\u0026quot; id=\u0026quot;todo_task_user_access\u0026quot;\u0026gt; \u0026lt;field name=\u0026quot;name\u0026quot;\u0026gt;todo.task.user\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026quot;model_id\u0026quot; ref=\u0026quot;model_todo_task\u0026quot;/\u0026gt; \u0026lt;field name=\u0026quot;group_id\u0026quot; ref=\u0026quot;base.group_user\u0026quot;/\u0026gt; \u0026lt;field name=\u0026quot;perm_read\u0026quot; eval=\u0026quot;1\u0026quot;/\u0026gt; \u0026lt;field name=\u0026quot;perm_create\u0026quot; eval=\u0026quot;1\u0026quot;/\u0026gt; \u0026lt;field name=\u0026quot;perm_write\u0026quot; eval=\u0026quot;1\u0026quot;/\u0026gt; \u0026lt;field name=\u0026quot;perm_unlink\u0026quot; eval=\u0026quot;1\u0026quot;/\u0026gt; \u0026lt;/record\u0026gt; \u0026lt;/data\u0026gt; \u0026lt;/odoo\u0026gt;  Questa codice aggiunge una regola di acl con id todo_task_user_access che viene applicata al modello todo.task sul gruppo base.group.user dando tutti i permessi di lettura, scrittura, creazione e cancellazione. Il gruppo base.group.user è un gruppo generico di Odoo a cui fanno parte tutti gli utenti del sistema.\nIn questo caso abbiamo aggiunto al tag data il valore noupdate. Questo dice ad Odoo di creare la riga nel database al primo upgrade, ma di non aggiornarla durante un successivo upgrade se già presente. Questo perchè questo tipo di dati può essere modificato dall\u0026rsquo;amministratore direttamente da interfaccia web in produzione e non vogliamo che vengano resettate queste modifiche ad un successivo upgrade del modulo.\n Come per le viste dobbiamo poi specificare nel file __manifest__.py l\u0026rsquo;esistenza di questa regola, apriamo quindi il file manifesto e modifichiamolo come segue:\n{ 'name': 'Applicazione TODO', 'description': 'Gestisci i tuoi TODO', 'author': 'Fabrizio Arzeni', 'depends': ['base'], 'application': True, 'data': [ 'security/todo_model_acl.xml', # \u0026lt;-- Aggiungiamo questa riga 'views/todo_menu.xml', 'views/todo_views.xml', ] }  Avendo aggiunto una nuova risorsa dobbiamo ricordarci di fare l\u0026rsquo;upgrade del modulo lanciando da terminale:\n$ docker-compose run odoo upgrade todo_app  A questo punto il messaggio di WARNING dovrebbe essere scomparso e tutti i nostri utenti hanno ora accesso al modello del nostro modulo.\nRow-level access rule Immagina di desiderare che gli utenti che usano il nostro modulo possano accedere solo ai dati creati da loro stessi. Le regole di accesso non sono sufficienti per specificare questa logica, perchè anche in questo caso tutti avrebbero gli stessi permessi di accesso, cambierebbe solo su quali dati possono applicarle.\nIn questo caso si utilizzano le regole di accesso per riga, che selezionano tramite un domain i record ai quali applicare le regole di accesso generali. Nel nostro caso vorremo che gli utenti abbiano accesso solo a quei record che hanno il campo create_user uguale a quello dell\u0026rsquo;utente che sta utilizzando il sofware ma possono essere espresse anche regole ben più complesse.\nCome per le Access Control List le regole di riga vengono salvate in una specifica tabella di Odoo che può essere visualizzata andando nella sezione\nSettings -\u0026gt; Technical -\u0026gt; Security -\u0026gt; Record Rules\ne sempre come le ACL possiamo creare delle regole aggiungendole al file di security che abbiamo creato in precedenza. Quindi apriamo il file _security/todo_model_acl.xml e aggiungiamo dopo il record creato in precedenza\n\u0026lt;record model=\u0026quot;ir.model.access\u0026quot; id=\u0026quot;todo_task_user_rule\u0026quot;\u0026gt; \u0026lt;field name=\u0026quot;name\u0026quot;\u0026gt;todo.task.user.rule\u0026lt;/field\u0026gt; \u0026lt;field name=\u0026quot;model_id\u0026quot; ref=\u0026quot;model_todo_task\u0026quot;/\u0026gt; \u0026lt;field name=\u0026quot;domain_force\u0026quot;\u0026gt; [('create_uid', '=', user.id)] \u0026lt;/field\u0026gt; \u0026lt;field name=\u0026quot;groups\u0026quot; eval=\u0026quot;[4, ref('base.group_user')]\u0026quot;/\u0026gt; \u0026lt;/record\u0026gt;  Se tutto è andato bene la regola sarà aggiunta.\nContinua Il nostro modulo sembra essere ad un buon punto ormai da meritare possiamo quindi andare a scoprire come si modificano le applicazioni esistenti\n"
},
{
	"uri": "https://metadonors.github.io/odoo.workshop/views/",
	"title": "Le Viste",
	"tags": [],
	"description": "",
	"content": " Chapter X Some Chapter title Lorem Ipsum.\n"
},
{
	"uri": "https://metadonors.github.io/odoo.workshop/",
	"title": "Index",
	"tags": [],
	"description": "",
	"content": " Mantova, 4 Luglio 2018 Odoo WorkShop Riferimenti L\u0026rsquo;inizio del corso:\nOdoo Workshoop\nIl modulo che svilupperemo:\nTodo List App\nIl nostro repository di riferimento:\nOdoo 11 - Immagine Docker\nLa documentazione ufficiale di odoo:\nDocumentazione Odoo\nLa nostra azienda:\nMetadonors\n"
},
{
	"uri": "https://metadonors.github.io/odoo.workshop/application_logic/",
	"title": "Logica applicativa",
	"tags": [],
	"description": "",
	"content": " Chapter 6 Logica applicativa Lorem Ipsum.\n"
},
{
	"uri": "https://metadonors.github.io/odoo.workshop/api/",
	"title": "Api esterne",
	"tags": [],
	"description": "",
	"content": " Chapter 7 Some Chapter title Lorem Ipsum.\n"
},
{
	"uri": "https://metadonors.github.io/odoo.workshop/website/",
	"title": "Sito Web Esterno",
	"tags": [],
	"description": "",
	"content": " Chapter 8 Some Chapter title Lorem Ipsum.\n"
},
{
	"uri": "https://metadonors.github.io/odoo.workshop/resources/",
	"title": "Altre Risorse",
	"tags": [],
	"description": "",
	"content": " Chapter 9 Some Chapter title Lorem Ipsum.\n"
},
{
	"uri": "https://metadonors.github.io/odoo.workshop/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://metadonors.github.io/odoo.workshop/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]